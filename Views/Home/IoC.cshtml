@{
	ViewData["Title"] = "IoC";
}

<div class="text-center">
	<h1 class="display-4">Інверсія управління</h1>
</div>

<p>
	<b>IoC</b>Inversion of Control - Інверсія управління життєвим циклом об'єктів.
	Патерн проєктування відповідно до якого задачі створення, використання та знищення
	об'єктів перекладаються на спціалізований модуль (Інжектор, контейнер сервісів).
	Замість інструкцій <code>new Service()</code> у кожному контролері, який потребує
	об'єкту Service, даний об'єкт реєструється один раз, а споживачі (контрорели)
	звертаються до цього об'єкту за допомогою інжекції. Можна порівняти ідею з
	глобальними об'єктами.
</p>

<p>
	<b>Не плутати:</b> <br />
	<b>IoC</b> - Inversion of Control - патерн<br />
	<b>DIP</b> - Dependency Inversion Principle (SOLID) - принцип<br />
	<b>DI</b> - Dependency Injection - спосіб передачи посилань на сервіси<br />
</p>

<p>
	IoC впроваджено в ASP "з коробки".
	Процес користування можна описати наступними кроками
</p>

<ol>
	<li>
		(Одноразово) - створюємо директорію "Services"
	</li>
	<li>
		Визначаємось з сервісом, що знадобиться у різних "місцях". Наприклад, 
		це сервіс часу, що повертає timestamp
	</li>
	<li>
		Створюємо директорію дял даної служби (наприклад, Timestamp)
		у загальній директорії "Services"
	</li>
	<li>
		Утворюємо інтерфейс ITimestampService (у директорії Timestamp),
		утворюємо клас-імплементацію інтерфейсу SystemTimestampService (у тій же директорії)
	</li>
	<li>
		Реєструемо сервіс у Program.cs
	</li>
	<li>
		Інжектуємо сервіс у потрібному місці (див. HomeController), виводимо на
		представленні: @ViewData["timestamp"] / @ViewData["timestampCode"]
	</li>
	<li>
		За потреби змінити роботи сервісу користуємось принципом OCP (SOLID)
		не змінюємо, а доповнюємо - створюємо новий клас, наприклад UnixTimestampService
		(у директорії Timestamp). Змінюємо реєстрацію сервісу у Program.cs
	</li>
</ol>